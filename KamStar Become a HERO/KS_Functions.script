
procedure GroupHpInvulnerableSet(aGroupID : array of Integer; aInvulnerable : Boolean);
var I, K : Integer;
begin
	for K := 0 to high(aGroupID) do 
		for I := 0 to States.GroupMemberCount(aGroupID[K]) do
			A.UnitHPSetInvulnerable(States.GroupMember(aGroupID[K],I),aInvulnerable);
	
end;
function CheckTime(aTime : Integer) : Boolean;
begin
	If States.GameTime = aTime then 
		Result := true;
end;
function GetUnitNextLevel(aType : Integer) : Integer;
begin
	case aType of
		14 : Result := 15;
		15 : Result := 16;
		16 : Result := 23;
		17 : Result := 18;
		19 : Result := 20;
		21 : Result := 22;
		23 : Result := 26;
		24 : Result := 19;
		25 : Result := 17;
		27 : Result := 21;
		else Result := aType;
	end;
end;
function GetUnitMaxLevel(aType : Integer) : Integer;
begin
	case aType of
		14 : Result := 26;
		15 : Result := 26;
		16 : Result := 26;
		17 : Result := 18;
		19 : Result := 20;
		21 : Result := 22;
		23 : Result := 26;
		24 : Result := 20;
		25 : Result := 18;
		27 : Result := 22;
		else Result := aType;
	end;
end;

Procedure UpgradeArmy(aPlayer:Integer; aMax : Boolean);
var AUnits:array of integer;
	LEA,GroupLeader:Integer;
begin	
	AUnits:=States.PlayerGetAllGroups(aPlayer);
	For LEA := 0 to length(AUnits)-1 do begin
		GroupLeader:=States.GroupMember(AUnits[LEA],0);
		If GroupLeader <>Hero then begin
			If not aMax then 
				Actions.GiveGroup(aPlayer,GetUnitNextLevel(States.UnitType(GroupLeader)),States.UnitPositionX(GroupLeader),States.UnitPositionY(GroupLeader),States.UnitDirection(GroupLeader),States.GroupMemberCount(AUnits[LEA]),States.GroupColumnCount(AUnits[LEA]))
			else 
				Actions.GiveGroup(aPlayer,GetUnitMaxLevel(States.UnitType(GroupLeader)),States.UnitPositionX(GroupLeader),States.UnitPositionY(GroupLeader),States.UnitDirection(GroupLeader),States.GroupMemberCount(AUnits[LEA]),States.GroupColumnCount(AUnits[LEA]));
				
			Actions.GroupKillAll(AUnits[LEA],true)
		end;
	end;
end;


function HeroInVillage(HeroPos : TKMPoint) : Integer;
var I, K : Integer;
begin
	Result := -1;
	for I := 0 to 5 do	
		If not VillageVisited[I] then 
			for K := 0 to high(VillageQuestGiver[I].QPontsToReveal) do
				If States.FogRevealed(0,VillageQuestGiver[I].QPontsToReveal[K].X,VillageQuestGiver[I].QPontsToReveal[K].Y) then 
					Result := I;
			
	If Result <> -1 then 	
	begin
		VillageVisited[Result] := true;
	end;
end;


function HeroNearbyEmissary(HeroPos : TKMPoint; Emissary : Integer) : Boolean;
var aPos : TKMPoint;
begin
	Result := false;
	aPos := U.KMPoint(255,255);
	case Emissary of
		1 : If not States.GroupDead(Emissary1) then aPos := States.UnitPosition(States.GroupMember(Emissary1,0));
		4 : If not States.GroupDead(Emissary4) then	aPos := States.UnitPosition(States.GroupMember(Emissary4,0));
		else Exit;
	end;
	If HeroPos = U.KMPoint(aPos.X,aPos.Y+2) then
	begin
		Result := True;
		EmissaryStats[Emissary] := eTalkStart;
	end;
end;


function GetArmyCountMultiPL(Players :array of Integer) : Integer;
var I : Integer;
begin
	for I := low(Players) to high(Players) do
		Result := Result + S.StatArmyCount(Players[I]);
end;

function GetUnitCosts(aType :Integer) :array of Integer;
begin
	case aType of
		14 : Result := [20];
		15 : Result := [20,16,18];
		16 : Result := [21,19,17];
		17 : Result := [18,24];
		18 : Result := [19,25];
		19 : Result := [18,22];
		20 : Result := [19,23];
		21 : Result := [20,16,18,26];
		22 : Result := [26,21,19,17];
		
		23,26 : Result := [8];
		24 : Result := [2];
		25 : Result := [3];
		27 : Result := [5];
	end;
end;
function GetHouseMSG(aType :Integer) :Ansistring;
begin
	case aType of
		0 : Result := '<$6>';
		1 : Result := '<$23>';
		2 : Result := '<$25>';
		3 : Result := '<$15>';
		4 : Result := '<$11>';
		5 : Result := '<$12>';
		6 : Result := '<$4>';
		7 : Result := '<$19>';
		8 : Result := '<$7>';
		9 : Result := '<$3>';
		10 : Result := '<$26>';
		12 : Result := '<$27>';
		13 : Result := '<$0>';
		14 : Result := '<$2>';
		15 : Result := '<$24>';
		16 : Result := '<$18>';
		17 : Result := '<$5>';
		18 : Result := '<$14>';
		19 : Result := '<$10>';
		20 : Result := '<$20>'; 
		21 : Result := '<$8>';
		22 : Result := '<$22>';
		24 : Result := '<$80>';
		25 : Result := '<$17>';
		27 : Result := '<$1>';
		28 : Result := '<$9>';
		29 : Result := '<$13>';
	end;
end;

function GetNextTree(aTreeID :Integer) :Integer;
begin
	case aTreeID of
		88 : Result := aTreeID+1;
		89 : Result := aTreeID+1;
		
		92 : Result := aTreeID+1;
		93 : Result := aTreeID+1;
		94 : Result := aTreeID+1;
		
		97 : Result := aTreeID+1;
		98 : Result := aTreeID+1;
		99 : Result := aTreeID+1;
		
		102 : Result := aTreeID+1;
		103 : Result := aTreeID+1;
		104 : Result := aTreeID+1;
		
		107 : Result := aTreeID+1;
		108 : Result := aTreeID+1;
		109 : Result := aTreeID+1;
		
		112 : Result := aTreeID+1;
		113 : Result := aTreeID+1;
		
		116 : Result := aTreeID+1;
		117 : Result := aTreeID+1;
		118 : Result := aTreeID+1;
		
		121 : Result := aTreeID+1;
		122 : Result := aTreeID+1;
		123 : Result := aTreeID+1;
		
		149 : Result := aTreeID+1;
		150 : Result := aTreeID+1;
		153 : Result := aTreeID+1;
		154 : Result := aTreeID+1;
		157 : Result := aTreeID+1;
		158 : Result := aTreeID+1;
		159 : Result := aTreeID+1;
		162 : Result := aTreeID+1;
		163 : Result := aTreeID+1;
		164 : Result := aTreeID+1;
		
		167 : Result := aTreeID+1;
		168 : Result := aTreeID+1;
		169 : Result := aTreeID+1;
		else Result := aTreeID;
	end;
end;

Procedure RemoveAttackToMultiPL(Players :array of Integer);
var I : Integer;
begin
	for I := low(Players) to high(Players) do
		Actions.AIAttackRemoveAll(Players[I]);
end;

Procedure StartCinematic(Mode, aDir : Integer);
begin
	If Mode = 0 then 
	begin
		Actions.CinematicStart(0);
		Actions.CinematicPanTo(0,States.UnitPositionX(Hero),States.UnitPositionY(Hero),0);
		Actions.GameSpeed(1);
		InCinematic := true;
		//Actions.GameSpeedChangeAllowed(false);
	end else
	begin
		Actions.CinematicEnd(0);
		Actions.GameSpeed(1);
		InCinematic := false;
		//Actions.GameSpeedChangeAllowed(true);
	end;
	Actions.UnitDirectionSet(Hero,aDir);
end;

function GetHeroStatDelta(aMode : Integer) : Ansistring;
var aDifference : array[0..3] of integer;
	aColor : Ansistring;
begin	
	Result := '';
	case aMode of 
		0:aDifference[aMode] := HeroStats[0].MultiHealth - HeroStats[1].MultiHealth;
		1:aDifference[aMode] := HeroStats[0].Attack - HeroStats[1].Attack;
		2:aDifference[aMode] := HeroStats[0].Defense - HeroStats[1].Defense;
		3:aDifference[aMode] := HeroStats[0].Haste - HeroStats[1].Haste;
	end;
	If aDifference[aMode] = 0 then 
		Exit;
	
	If aMode = 3 then 
	begin
		if aDifference[aMode] < 0 then 
			aColor := '[$00FF00]  '
		else
			aColor := '[$0000ff]  ';
	end else		
		if aDifference[aMode] > 0 then 
			aColor := '[$00FF00]  '
		else
			aColor := '[$0000ff]  ';
	If aDifference[aMode] > 0 then 
		Result := Result + aColor+'+'+IntToStr(aDifference[aMode]);
	If aDifference[aMode] < 0 then 
		Result := Result + aColor+IntToStr(aDifference[aMode]);
	
	Result := Result + ' <$' + IntToStr(91+aMode) + '>[$ffFFff]';
end;

Procedure ShowHeroStats;
var I, K : Integer;
	aPos,aPos2 : TKMPoint;
	finString : Ansistring;
begin
	aPos := States.UnitPosition(Hero);
	aPos2 := VillageQuestGiver[5].QPos;
	//Actions.UnitHungerSet(Hero,27000)
	If length(HeroInventory[7]) = 0 then 
		Exit;
	Actions.OverlayTextSet(-1,'');
	If not States.HouseRepair(MainStoreHouse[0]) then 
	begin
		If  HeroStats[0].Health>0 then 
		begin
			If (States.GameTime < HeroStats[0].ChangeTime) then 
			begin
				finString := ''
				Actions.OverlayTextAppend(-1,'<$91> : [$00FF00]' +IntToStr(HeroStats[0].Health)+'[$FFFFFF] / [$0000FF]'+IntToStr(HPmax)+'[$FFFFFF]' + GetHeroStatDelta(0));
				Actions.OverlayTextAppend(-1,'|<$92> : [$00FF00]' +IntToStr(HeroStats[0].Attack)+'[$FFFFFF]' + GetHeroStatDelta(1));
				Actions.OverlayTextAppend(-1,'|<$93> : [$00FF00]' +IntToStr(HeroStats[0].Defense)+'[$FFFFFF]' + GetHeroStatDelta(2));
				//Actions.OverlayTextAppend(-1,'|Position : ' +IntToStr(aPos2.X)+' : '+IntToStr(aPos2.Y) + '[$FFFFFF]');
				Actions.OverlayTextAppend(-1,'|<$94> : [$00FF00]' + IntToStr(HeroStats[0].Haste)+'[$FFFFFF]' + GetHeroStatDelta(3));	
				Actions.OverlayTextAppend(-1,'[$00FF00]||Hero Inventory : [$FFFFFF]');
			end else
			begin
				Actions.OverlayTextAppend(-1,'<$91> : [$00FF00]' +IntToStr(HeroStats[0].Health)+'[$FFFFFF] / [$0000FF]'+IntToStr(HPmax)+'[$FFFFFF]');
				Actions.OverlayTextAppend(-1,'|<$92> : [$00FF00]' +IntToStr(HeroStats[0].Attack)+'[$FFFFFF]');
				Actions.OverlayTextAppend(-1,'|<$93> : [$00FF00]' +IntToStr(HeroStats[0].Defense)+'[$FFFFFF]');
				//Actions.OverlayTextAppend(-1,'|Position : ' +IntToStr(aPos2.X)+' : '+IntToStr(aPos2.Y) + '[$FFFFFF]');
				Actions.OverlayTextAppend(-1,'|<$94> : [$00FF00]' + IntToStr(HeroStats[0].Haste)+'[$FFFFFF]');	
				Actions.OverlayTextAppend(-1,'[$00FF00]||Hero Inventory : [$FFFFFF]');
			end;
			for I := low(HeroInventory)to high(HeroInventory) do
			begin
				K := HeroInventoryString[I]
				Actions.OverlayTextAppend(-1,'<$'+IntToStr(50+I)+'>' + HeroInventory[I][K].Name);
			end;
		end;
		
		If (States.UnitDead(Hero))then	
			Actions.OverlayTextAppend(-1,'|Your Hero is [$0000FF]DEAD');
			
	end else
	begin	
		Actions.OverlayTextAppend(-1,'<$95>');
		for I := 1 to 6 do			
			If States.PlayerAllianceCheck(0,I) then 
				Actions.OverlayTextAppend(-1,'|[$' + States.PlayerColorText(I)+']<$'+IntToStr(96+I)+'>[$ffffff]');
				
		Actions.OverlayTextAppend(-1,'||<$96>');
		for I := 1 to 6 do		
			If not States.PlayerAllianceCheck(0,I) and not States.PlayerAllianceCheck(I,0) then 
				Actions.OverlayTextAppend(-1,'|[$' + States.PlayerColorText(I)+']<$'+IntToStr(96+I)+'>[$ffffff]');
			
		Actions.OverlayTextAppend(-1,'|<$103>');	
		for I := 1 to 6 do			
			If not States.PlayerAllianceCheck(0,I) and States.PlayerAllianceCheck(I,0) then 
				Actions.OverlayTextAppend(-1,'|[$' + States.PlayerColorText(I)+']<$'+IntToStr(96+I)+'>[$ffffff]');
		
		If States.GameTime mod 50 = 0 then 
		begin	
			for I := 1 to 6 do	
				If States.PlayerAllianceCheck(0,I) then 
				begin
					aResourceString := '';
					If States.HouseResourceAmount(MainStoreHouse[I], 1) < 20 then 
						aResourceString := aResourceString + '|  ' + States.WareTypeName(1);
					If States.HouseResourceAmount(MainStoreHouse[I], 2) < 10 then 
						aResourceString := aResourceString + '|  ' + States.WareTypeName(2);
					If States.HouseResourceAmount(MainStoreHouse[I], 7) < 20 then 
						aResourceString := aResourceString + '|  ' + States.WareTypeName(7);
					
					If (States.HouseResourceAmount(MainStoreHouse[I], 8) + 
						States.HouseResourceAmount(MainStoreHouse[I], 10) + 
						States.HouseResourceAmount(MainStoreHouse[I], 13) + 
						States.HouseResourceAmount(MainStoreHouse[I], 27) < 50) then 
						aResourceString := aResourceString + '|  <$105>';
					If aResourceString <> '' then 
						aResourceString := '|[$' + States.PlayerColorText(I)+']<$'+IntToStr(96+I)+'>[$ffffff] :' + aResourceString;
				end;
		end;
		If aResourceString <> '' then 
		begin
			Actions.OverlayTextAppend(-1,'|<$104>');
			Actions.OverlayTextAppend(-1,aResourceString);
		end;
	end;
	
	If MinersKilled > 0 then 
		Actions.OverlayTextAppend(-1,'|<$635>' + IntToStr(12-MinersKilled));
		
	If States.GameTime > VillageQuestGiver[4].QEndTime then 
		If VillageQuestGiver[4].QEventType = 2 then 
				Actions.OverlayTextAppendFormatted(-1,'|<$632>',[30-QuestInteger[4]]);
				
	If States.GameTime > VillageQuestGiver[2].QEndTime then 
		If VillageQuestGiver[2].QEventType = 5 then
				Actions.OverlayTextAppendFormatted(-1,'|<$633>',[20-QuestInteger[5]]);
				
	If States.GameTime > VillageQuestGiver[3].QTime then 
		if VillageQuestGiver[3].QEventType = 2 then
				Actions.OverlayTextAppendFormatted(-1,'|<$652>',[5-TreesToChop]);
	If Player2Attacks then 
		Actions.OverlayTextAppend(-1,'|'+IntToStr(HeroStats[0].MultiHealth));	
	//Actions.OverlayTextAppend(-1,'|'+IntToStr(HeroStats[1].MultiHealth));	
end;

Function Point(X,Y:Integer) : TKMPoint;
begin
	Result := U.KMPoint(X,Y);
end;

Procedure GiveHouseMultipleTimes(aPlayer,aType:Integer; WithUnits, WithRoad:Boolean; aPoses:array of TKMPoint);
var I : Integer;
	aPos : TKMPoint;
begin
	aPos := States.HousePosition(MainStoreHouse[aPlayer]);
	for I := low(aPoses) to high(aPoses) do 
	begin
		
		A.GiveHouse(aPlayer,aType,aPoses[I].X,aPoses[I].Y);
		If WithUnits then
			A.GiveUnit(aPlayer,0,aPoses[I].X,aPoses[I].Y+1,4);	
		If WithUnits then	
			A.GiveUnit(aPlayer,S.HouseTypeToOccupantType(aType),aPoses[I].X,aPoses[I].Y+1,4);
		If WithRoad then	
			A.PlanConnectRoad(aPlayer,aPoses[I].X,aPoses[I].Y+1,aPos.X,aPos.Y+1,true);
	end;
end;

function FromIToPL(I:Integer):Integer;
begin
	case I of 
		0:Result := 13;
		1:Result := 14;
		2:Result := 12;
		3:Result := 12;
	end;
end;

procedure GiveResourcesFromVillage(aPlayer:Integer);
begin
	case aPlayer of
		0 : A.GiveWares(0,27,10);
		1 : A.GiveWares(0,5,10);
		2 : A.GiveWares(0,7,10);
		3 : A.GiveWares(0,0,10);
	end;
end;



function ArrayElementIndex(aElement : String; aArray : array of String) : Integer;
var I : Integer;
begin
	Result := -1;
	for I := low(aArray) to high(aArray) do
		If aElement = aArray[I] then
			Result := I;
end;

function ArrayElementIndexI(aElement : integer; aArray : array of Integer) : Integer;
var I : Integer;
begin
	Result := -1;
	for I := low(aArray) to high(aArray) do
		If aElement = aArray[I] then
			Result := I;
end;

function ItemsArrayElementIndex(aElement : String; aArray : array of KS_Item) : Integer;
var I : Integer;
begin
	Result := -1;	
	for I := low(aArray) to high(aArray) do
		If aElement = aArray[I].Name then
			Result := I;
end;

function SetKS_Item(Name : String;	Attack,	Defense, Health, aTypeTo, Haste, ID : Integer) : KS_Item;
begin
	Result.Name := Name;
	Result.Attack := Attack;
	Result.Defense := Defense;
	Result.Health := Health;
	Result.aTypeTo := aTypeTo;
	Result.Haste := Haste;
end;

Procedure KillAllGroups(aPlayer:Integer);
var LEA : Integer;
	AllGroups : array of Integer;
begin
	AllGroups := States.PlayerGetAllGroups(aPlayer);
	for LEA := 0 to length(AllGroups)-1 do
		A.GroupKillAll(AllGroups[LEA],true);
end;

Procedure SetWin(aWinType : KS_WinType);
begin
	Win.WinTime := States.GameTime;
	Win.WinType := aWinType;
end;

function PointArrayRemoveIndex(aArray : array of TKMPoint; aIndexes :array of Integer) : array of TKMPoint;
var I, K : integer;
	newArray : array of TKMPoint;
begin
	for I := 0 to high(aArray) do
		If not U.ArrayHasElementI(I, aIndexes) then 
		begin
			K := length(newArray)
			SetLength(newArray, K+1);
			newArray[K] := aArray[I];
		end;
	Result := newArray;
end;

Function GetMessageNumber(aPlayer : Integer) : Ansistring;
var I, aIndex : Integer;
begin
	//A.ShowMsg(-1,'');
	Result := '';
	for I := 0 to 3 do	
		if PlayersFirstDefeated[I] = aPlayer then 
			aIndex := I;
	
	case aIndex of 
		0 : case PlayersFirstDefeated[aIndex] of 
				6: Result := '<$338>';
				5: Result := '<$347>';
				4: Result := '<$354>';
				1: Result := '';
			end;
		
		1 : case PlayersFirstDefeated[0] of 
				6:	case PlayersFirstDefeated[1] of 
						4: Result := '<$340>';
						5: Result := '<$339>';
						1: Result := '';
					end;
				5:	case PlayersFirstDefeated[1] of 
						1: Result := '';
						4: Result := '<$348>';
						6: Result := '<$351>';
					end;
				4:	case PlayersFirstDefeated[1] of 
						1: Result := '';
						5: Result := '<$353>';
						6: Result := '<$358>';
					end;
			end;
		
		2 : case PlayersFirstDefeated[0] of 
				6:	case PlayersFirstDefeated[1] of 
						4:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								5: Result := '<$345>';
							end;
						5:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								4: Result := '<$355>';
							end;
					end;
				5:	case PlayersFirstDefeated[1] of 
						4:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								6: Result := '<$349>';
							end;
						6:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								4: Result := '<$352>';
							end;
					end;
				4:	case PlayersFirstDefeated[1] of 
						5:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								6: Result := '<$382>';
							end;
						6:	case PlayersFirstDefeated[2] of 
								1: Result := '';
								5: Result := '<$359>';
							end;
					end;
					

			end;
	end;
	
end;

Procedure SetMultipleAlliances(aPlayers, aPlayers2 : array of Integer; aTrue : Boolean);
var I , K : Integer;
begin
	for I := 1 to high(aPlayers) do
			A.FogCoverAll(I);
	for K := 1 to high(aPlayers2) do
			A.FogCoverAll(K);
		
	for I := 0 to high(aPlayers) do
		for K := 0 to high(aPlayers2) do
			A.PlayerAllianceChange(aPlayers[I],aPlayers2[K],true,aTrue);
end;


Procedure ChangeHeroTo(aPos : TKMPoint; aType : Integer);
var aDir, aHunger : Integer;
begin
	If U.ArrayHasElementI(aType, [21,27]) then 
		case HeroInventory[0][HeroInventoryString[0]].Name of													
			'Iron axe' 							: aType := 21;	
			'The Ancient Sword' 				: aType := 22;	
			'The Sword of the God' 				: aType := 22;		
		end;
	
	If States.UnitType(Hero) = aType then 
		Exit;
	
	aDir := S.UnitDirection(Hero);
	aHunger := S.UnitHunger(Hero)-1;
	Actions.UnitHPSetInvulnerable(Hero,false);
	Actions.UnitKill(Hero,true);
	Hero := S.GroupMember(Actions.GiveGroup(0,aType,aPos.X,aPos.Y-1,aDir,1,1),0);
	A.UnitHungerSet(Hero,aHunger);
	Actions.UnitHPSetInvulnerable(Hero,true);	
end;

Procedure ChangeHeroWithNoHorse;
var K , I : Integer;
begin
	
	K := HeroInventoryString[0];
	I:= HeroInventoryString[7];
	If HeroInventory[7][I].Name <> 'None' then 
		ChangeHeroTo(States.UnitPosition(Hero),HeroInventory[7][I].aTypeTo)
	else 
	case HeroInventory[0][K].Name of
		'Hand' 							:	ChangeHeroTo(States.UnitPosition(Hero),14);
		
		'Hand axe' 							:	If U.ArrayHasElement(HeroInventory[3][HeroInventoryString[3]].Name,['The Ancient Chestplate','The Gods Chestplate']) then 
													ChangeHeroTo(States.UnitPosition(Hero),HeroInventory[0][K].aTypeTo)
												else
													ChangeHeroTo(States.UnitPosition(Hero),HeroInventory[0][K].aTypeTo);
		'Sword Xiphos' 						: begin
													ChangeHeroTo(States.UnitPosition(Hero),HeroInventory[0][K].aTypeTo);
													HeroInventoryString[7] := ItemsArrayElementIndex('Old Horse',HeroInventory[7]);
											end;
		else ChangeHeroTo(States.UnitPosition(Hero),HeroInventory[0][K].aTypeTo);
	end;
end;

Procedure SetInventoryStats(aIndex : Integer);
var I , K: Integer;
begin
	HeroStats[1].Attack := HeroStats[0].Attack;
	HeroStats[1].Defense := HeroStats[0].Defense;
	HeroStats[1].Haste := HeroStats[0].Haste;
	HeroStats[1].MultiHealth := HeroStats[0].MultiHealth;
	
	HeroStats[0].ChangeTime := States.GameTime + 300;
	HeroStats[0].MultiHealth := 0;
	
	If aIndex <> -1 then 
	begin	
		HeroStats[0].Attack := 0;
		HeroStats[0].Defense := 0;
		HeroStats[0].Haste := 0;
		//Attack2 := 0;
		//Defense2 := 1;
		//Iloczyn2 := 0;
		//Haste := 0;
		If length(HeroInventory[7]) > 0 then
		begin

			If HeroInventory[5][HeroInventoryString[5]].Name <> 'Boots of the Multigravitation'then 
			begin
				
				If HeroInventoryString[7] <> 0 then
				begin
					If U.ArrayHasElement(HeroInventory[0][HeroInventoryString[0]].Name, ['Lance','Pike','Double Axe', 'Long Bow', 'Crossbow']) then 
							HeroInventoryString[7] := 0;
					
					If U.ArrayHasElement(HeroInventory[0][HeroInventoryString[0]].Name, ['Double Axe']) then 
							HeroInventoryString[7] := 0;
				end;
			
				If U.ArrayHasElementI(HeroInventory[0][HeroInventoryString[0]].ID, [10,34,56]) then  
					HeroInventoryString[1] := 0;
			end else	
				If U.ArrayHasElement(HeroInventory[0][HeroInventoryString[0]].Name, ['Long Bow', 'Crossbow']) then 
						HeroInventoryString[7] := 0;
						
			If HeroInventory[6][HeroInventoryString[6]].Name = 'The Vial of Regeneration' then  
				HeroSpecialReg := 4
			else	
				HeroSpecialReg := 0;
			
			for I := 0 to 7 do
				If length(HeroInventory[I]) > 0 then
				begin						
					K := HeroInventoryString[I];
					HeroStats[0].Attack := HeroStats[0].Attack + HeroInventory[I][K].Attack;
					HeroStats[0].Defense := HeroStats[0].Defense + HeroInventory[I][K].Defense;
					HeroStats[0].Haste := HeroStats[0].Haste + HeroInventory[I][K].Haste
				end;
			If States.GameTime > 10 then 
				ChangeHeroWithNoHorse;				
			
			If HeroInventory[5][HeroInventoryString[5]].Name = 'Boots of the Multigravitation'then 
				HeroStats[0].Haste := 3;

		end;
		
		If HeroInventory[0][HeroInventoryString[0]].Name = 'Sword Xiphos' then 
			If HeroInventory[1][HeroInventoryString[1]].Name = 'Sword Xiphos' then 
				HeroStats[0].Attack := HeroStats[0].Attack + 7;
				
	end;
	for I := 0 to 7 do
		If length(HeroInventory[I]) > 0 then
		begin						
			K := HeroInventoryString[I];
			HeroStats[0].MultiHealth := HeroStats[0].MultiHealth + HeroInventory[I][K].Health;
		end;
		
	HeroStats[0].MultiHealth := 50 + HeroStats[0].MultiHealth + HeroSpecialHPPoints;
	
	If States.GameTime < 10 then
	begin	
		HeroStats[1].Attack := HeroStats[0].Attack;
		HeroStats[1].Defense := HeroStats[0].Defense;
		HeroStats[1].Haste := HeroStats[0].Haste;
		HeroStats[1].MultiHealth := HeroStats[0].MultiHealth;
	end;
	
	HPmax:= HeroStats[0].MultiHealth;
	
	ShowHeroStats;
	
	If HeroStats[0].Health > HPmax then 
		HeroStats[0].Health := HPmax;
end;

Procedure AddInventoryItem(aIndex : Integer; Item : KS_Item);
var I : Integer;
begin
	If ItemsArrayElementIndex(Item.Name,HeroInventory[aIndex]) <> -1 then 
		Exit;
		
	I := length(HeroInventory[aIndex]);
	SetLength(HeroInventory[aIndex], I+1);
	HeroInventory[aIndex][I] := Item;	
	HeroInventoryString[aIndex] := I;	
	SetInventoryStats(aIndex);
	
end;

function GetItemName(aIndex : Integer) : AnsiString;
begin
	case aIndex of 
		0:	Result := 'Hand';
		1:	Result := 'Hand';
	
		2:	Result := 'None';
		3:	Result := 'None';
		4:	Result := 'None';
		5:	Result := 'None';
		6:	Result := 'None';
		7:	Result := 'None';
	
		8:	Result := 'Hand Axe';
		9: 	Result := 'Old Horse';
		//B class
		10: Result := 'The Ancient Sword';
		11:	Result := 'The Ancient Shield';
		12:	Result := 'The Ancient Helmet';
		13:	Result := 'The Ancient Chestplate';
		
		14:	Result := 'Stick';
		15:	Result := 'Pickaxe';
		16:	Result := 'Fork';
		17:	Result := 'Lance';
		18:	Result := 'Long Bow';
		19:	Result := 'Iron axe';
		20: Result := 'Hand axe';
		
		21:	Result := 'Sword Xiphos';
		22:	Result := 'Sword Xiphos';
		23:	Result := '[$FFFF00]Royal Horse [$FFFFFF]';
		
		24:	Result := 'Wooden Shield';
		25:	Result := 'Wooden Helmet';
		26:	Result := 'Leather Armor';
		27:	Result := 'Leather Leggings';
		28:	Result := 'Leather Boots';
		
		29:	Result := '[$FFFF00]Royal Horse [$FFFFFF]';
		30:	Result := 'Iron Helmet';
		31:	Result := 'Long Sword';
		32: Result := 'Pike';
		33:	Result := 'Crossbow';
		34:	Result := 'Double Axe';
		
		35:	Result := 'Long Shield';
		36:	Result := 'Iron Helmet';
		37:	Result := 'Iron Armor';
		38:	Result := 'Iron Leggings';
		39:	Result := 'Iron Boots';
		
		40:	Result := 'Mustang';
		
		// A class
		41:	Result := 'Ion Spear';
		42:	Result := 'Ion Shell';
		43:	Result := 'Scanning Glasses';
		44:	Result := 'Power Chest Belt';
		45:	Result := 'Multi Slots';
		46:	Result := 'Boots of the Multigravitation';
		47:	Result := 'The Vial of Regeneration';
		
		48:	Result := 'Woodcutter`s Axe';
		
		49:	Result := 'The Ancient Leggings';
		50:	Result := 'The Ancient Boots';
		
		51:	Result := 'Medicinal Herbs';
		52:	Result := 'Cart of Wood';
		53:	Result := 'Cart of Coal';
		54: Result := 'Cart of Stone';
		55:	Result := 'Cart of Gold';
		
		56:	Result := 'Meryton`s Sword';

	end;
	
end;
Procedure GiveItemFromID(aIndex : Integer);
begin
	case aIndex of 
		0:	AddInventoryItem(0,SetKS_Item('Hand',3,0,0,14,0, aIndex));
		1:	AddInventoryItem(1,SetKS_Item('Hand',3,0,0,14,0, aIndex));
	
		2:	AddInventoryItem(2,SetKS_Item('None',0,0,0,-1,0, aIndex));
		3:	AddInventoryItem(3,SetKS_Item('None',0,0,0,-1,0, aIndex));
		4:	AddInventoryItem(4,SetKS_Item('None',0,0,0,-1,0, aIndex));
		5:	AddInventoryItem(5,SetKS_Item('None',0,0,0,-1,0, aIndex));
		6:	AddInventoryItem(6,SetKS_Item('None',0,0,0,-1,0, aIndex));
		7:	AddInventoryItem(7,SetKS_Item('None',0,0,0,-1,0, aIndex));
	
		8:	AddInventoryItem(0,SetKS_Item('Hand Axe',10,0,0,14,3, aIndex));
		9: 	AddInventoryItem(7,SetKS_Item('Old Horse',1,2,48,27,1, aIndex));
		//B class
		10: AddInventoryItem(0,SetKS_Item('The Ancient Sword',34,0,0,22,6, aIndex));
		11:	AddInventoryItem(1,SetKS_Item('The Ancient Shield',0,9,18,-1,5, aIndex));
		12:	AddInventoryItem(2,SetKS_Item('The Ancient Helmet',0,8,0,-1,3, aIndex));
		13:	AddInventoryItem(3,SetKS_Item('The Ancient Chestplate',0,9,0,-1,3, aIndex));	
		
		14:	AddInventoryItem(1,SetKS_Item('Stick',3,1,1,14,1, aIndex));//woodcutter
		15:	AddInventoryItem(0,SetKS_Item('Pickaxe',12,1,1,14,6, aIndex));//querry
		16:	AddInventoryItem(0,SetKS_Item('Fork',9,1,1,14,4, aIndex));//farm
		17:	AddInventoryItem(0,SetKS_Item('Lance',20,0,0,19,4, aIndex));
		18:	AddInventoryItem(0,SetKS_Item('Long Bow',35,0,1,17,4, aIndex));
		19:	AddInventoryItem(0,SetKS_Item('Iron axe',14,0,0,15,7, aIndex));
		20:	AddInventoryItem(1,SetKS_Item('Hand axe',10,0,0,-1,3, aIndex));
		
		21:	AddInventoryItem(0,SetKS_Item('Sword Xiphos',12,0,0,27,3, aIndex));
		22:	AddInventoryItem(1,SetKS_Item('Sword Xiphos',12,0,0,27,3, aIndex));
		23:	AddInventoryItem(7,SetKS_Item('[$FFFF00]Royal Horse [$FFFFFF]',6,7,163,22,3, aIndex));
		
		24:	AddInventoryItem(1,SetKS_Item('Wooden Shield',0,2,3,-1,2, aIndex));
		25:	AddInventoryItem(2,SetKS_Item('Wooden Helmet',0,2,0,-1,2, aIndex));
		26:	AddInventoryItem(3,SetKS_Item('Leather Armor',0,5,1,-1,1, aIndex));
		27:	AddInventoryItem(4,SetKS_Item('Leather Leggings',0,3,0,-1,1, aIndex));
		28:	AddInventoryItem(5,SetKS_Item('Leather Boots',0,2,0,-1,1, aIndex));
		
		29:	AddInventoryItem(7,SetKS_Item('[$FFFF00]Royal Horse [$FFFFFF]',6,7,163,22,3, aIndex));
		30:	AddInventoryItem(2,SetKS_Item('Iron Helmet',0,4,0,-1,3, aIndex));
		31:	AddInventoryItem(0,SetKS_Item('Long Sword',26,0,0,16,4, aIndex));
		32:	AddInventoryItem(0,SetKS_Item('Pike',24,0,0,20,5, aIndex));
		33:	AddInventoryItem(0,SetKS_Item('Crossbow',60,1,2,18,5, aIndex));
		34:	AddInventoryItem(0,SetKS_Item('Double Axe',33,6,16,26,9, aIndex));
		
		35:	AddInventoryItem(1,SetKS_Item('Long Shield',0,4,6,-1,4, aIndex));
		36:	AddInventoryItem(2,SetKS_Item('Iron Helmet',0,4,0,-1,3, aIndex));
		37:	AddInventoryItem(3,SetKS_Item('Iron Armor',0,6,2,-1,3, aIndex));
		38:	AddInventoryItem(4,SetKS_Item('Iron Leggings',0,5,0,-1,2, aIndex));
		39:	AddInventoryItem(5,SetKS_Item('Iron Boots',0,3,0,-1,2, aIndex));
		
		40:	AddInventoryItem(7,SetKS_Item('Mustang',4,5,99,21,2, aIndex));
		
		// A class
		41:	AddInventoryItem(0,SetKS_Item('Ion Spear',65,5,17,22,14, aIndex));//right arm
		42:	AddInventoryItem(1,SetKS_Item('Ion Shell',4,6,311,-1,0, aIndex));//left arm
		43:	AddInventoryItem(2,SetKS_Item('Scanning Glasses',0,0,0,-1,1, aIndex));//helmet
		44:	AddInventoryItem(3,SetKS_Item('Power Chest Belt',0,35,0,-1,1, aIndex));//chestplate
		45:	AddInventoryItem(4,SetKS_Item('Multi Slots',0,0,0,-1,1, aIndex));//leggings
		46:	AddInventoryItem(5,SetKS_Item('Boots of the Multigravitation',0,5,0,-1,1, aIndex));//feet
		47:	AddInventoryItem(6,SetKS_Item('The Vial of Regeneration',0,0,0,-1,2, aIndex));//sakwa
		
		48:	AddInventoryItem(0,SetKS_Item('Woodcutter`s Axe',14,1,2,14,7, aIndex));	
		
		49:	AddInventoryItem(4,SetKS_Item('The Ancient Leggings',0,8,0,-1,2, aIndex));
		50:	AddInventoryItem(5,SetKS_Item('The Ancient Boots',0,7,0,-1,2, aIndex));
		
		51:	AddInventoryItem(6,SetKS_Item('Medicinal Herbs',0,0,0,-1,0, aIndex));
		52:	AddInventoryItem(6,SetKS_Item('Cart of Wood',0,0,0,-1,0, aIndex));
		53:	AddInventoryItem(6,SetKS_Item('Cart of Coal',0,0,0,-1,0, aIndex));
		54:	AddInventoryItem(6,SetKS_Item('Cart of Stone',0,0,0,-1,0, aIndex));
		55:	AddInventoryItem(6,SetKS_Item('Cart of Gold',0,0,0,-1,0, aIndex));
		
		56:	AddInventoryItem(0,SetKS_Item('Meriton`s Sword',43,0,0,-1,7, aIndex));

	end;
	
end;

procedure AddMultiMessages(aArrayI: array of AnsiString ; ItemsToGive : array of Integer);
var aLength, I : integer;
begin
	If length(aArrayI) > 0 then 
		for I := 0 to high(aArrayI) do 
		begin
			aLength := length(MultiMessages.aShowArray);
			SetLength(MultiMessages.aShowArray, aLength + 1);
			MultiMessages.aShowArray[aLength] := aArrayI[I];
		end;
		
	If length(ItemsToGive) > 0 then 
	begin
		aLength := length(MultiMessages.ItemAtLastMessage);
		SetLength(MultiMessages.ItemAtLastMessage, aLength + length(ItemsToGive) );
		for I := 0 to high(ItemsToGive) do
			MultiMessages.ItemAtLastMessage[aLength + I ] := ItemsToGive[I];
	end;
end;

Procedure GiveMultipleItemsWithNoMSG(aArray : array of Integer);
var I : Integer;
begin
	for I := 0 to high(aArray) do
		GiveItemFromID(aArray[I]);
end;

Procedure GiveMultipleItems(aArray : array of Integer);
var I : Integer;
	finString : AnsiString;
begin
	for I := 0 to high(aArray) do
	begin
		finString := finString + '|  ' + GetItemName(aArray[I]);
		GiveItemFromID(aArray[I]);
	end;
	AddMultiMessages(['<$161>' + finString], [])
end;

Procedure SetMSGWithItem(aArray : array of Integer);
var I : Integer;
	finString : AnsiString;
begin
	If length(aArray) <= 0 then 
		Exit;
		
	for I := 0 to high(aArray) do
		finString := finString + '|  ' + GetItemName(aArray[I]);
		
	AddMultiMessages(['<$161>' + finString], [])
end;


Procedure GiveSpecialItem;
var Random, aTrue : Integer;
	aName : AnsiString;
begin
	aTrue := -1;
	Random := U.RandomRangeI(41,47);
	case Random of
		41 : aName := 'Ion Spear';
		42 : aName := 'Ion Shell';
		43 : aName := 'Scanning Glasses';
		44 : aName := 'Power Chest Belt';
		45 : aName := 'Multi Slots';
		46 : aName := 'Boots of the Multigravitation';
		47 : aName := 'The Vial of Regeneration';
	end;
	
	
	If ItemsArrayElementIndex(aName,HeroInventory[Random-41]) = -1 then 
	begin
		AddMultiMessages([], [Random])
		aTrue := 0;
	end;
	If aTrue = -1 then 
		GiveSpecialItem;
end;

procedure SetNewMultiMessages(aArrayI : array of Integer; aModTime : Integer; ItemsToGive, GroupsToKill : array of Integer);
var I : Integer;
begin
	MultiMessages.aIndex := 0;
	MultiMessages.aModTime := aModTime;
	SetLength(MultiMessages.aShowArray,  length(aArrayI));
	for I := 0 to high(aArrayI) do	
		MultiMessages.aShowArray[I] := '<$' + IntToStr(aArrayI[I]) + '>';
		
	SetMSGWithItem(ItemsToGive);
	MultiMessages.ItemAtLastMessage := ItemsToGive;
	MultiMessages.GroupsToKill := GroupsToKill;
end;

procedure ShowMultiMessages(aIndex : integer; aArrayI : array of AnsiString);
var I : Integer;
begin
	A.ShowMSG(0, aArrayI[aIndex]);
	If aIndex = high(aArrayI) then 
	begin
		If length(MultiMessages.ItemAtLastMessage) > 0 then
			GiveMultipleItemsWithNoMSG(MultiMessages.ItemAtLastMessage);
			
		If length(MultiMessages.GroupsToKill) > 0 then
			for I := 0 to high(MultiMessages.GroupsToKill) do
			begin
				GroupHpInvulnerableSet([MultiMessages.GroupsToKill[I]],false)
				A.GroupKillAll(MultiMessages.GroupsToKill[I], true);
			end;
				
	end;
	MultiMessages.aIndex := aIndex + 1;
end;

Procedure GiveRandomFromRuins;
var Random, I, II : Integer;
	FinString : Ansistring;
begin
	FinString := '<$89>';
	Random := States.KaMRandomI(100);
	I := States.KaMRandomI(5)+1;
	II := States.KaMRandomI(5)+1;
	case Random of
		0..25 : begin
					FinString := FinString +'|' + States.WareTypeName(1) + ' : ' + IntToStr(I)
					FinString := FinString +'|' + States.WareTypeName(2) + ' : ' + IntToStr(II)
					A.GiveWares(0, 1, I);
					A.GiveWares(0, 2, II);
				end;
		26..50 : begin
					FinString := FinString +'|' + States.WareTypeName(0) + ' : ' + IntToStr(I)
					FinString := FinString +'|' + States.WareTypeName(5) + ' : ' + IntToStr(II)
					A.GiveWares(0, 0, I);
					A.GiveWares(0, 5, II);
				end;
		51..55 : begin
					FinString := FinString +'|' + States.WareTypeName(1) + ' : ' + IntToStr(I)
					FinString := FinString +'|' + States.WareTypeName(24) + ' : ' + IntToStr(II)
					A.GiveWares(0, 1, I);
					A.GiveWares(0, 24, II);
				end;
		56..85 : begin
					FinString := FinString +'|' + States.WareTypeName(1) + ' : ' + IntToStr(I)
					A.GiveWares(0, 1, I);
				end;
		86..100 : begin
					FinString := FinString +'|' + States.WareTypeName(0) + ' : ' + IntToStr(I)
					FinString := FinString +'|' + States.WareTypeName(1) + ' : ' + IntToStr(I)
					FinString := FinString +'|' + States.WareTypeName(2) + ' : ' + IntToStr(II)
					A.GiveWares(0, 0, I);
					A.GiveWares(0, 1, I);
					A.GiveWares(0, 2, II);
				end;
	end;
	A.ShowMSG(0, FinString);
end;


Function PosInRadius(aPos, aPoint : TKMPoint; aRadius : Integer) : boolean;
begin
	Result := false;
	If U.InAreaI(aPos.X,aPos.Y,aPoint.X - aRadius,aPoint.Y - aRadius,aPoint.X + aRadius,aPoint.Y + aRadius) then
		Result := true;

end;

procedure AddPatroll(aPlayer, aType : Integer; aPos1,aPos2 : TKMPoint);
var I : Integer;
begin
	I := length(Patrolls);
	SetLength(Patrolls, I + 1);
	Patrolls[I].aPos1 := aPos1;
	Patrolls[I].aPos2 := aPos2;
	Patrolls[I].aID := A.GiveGroup(aPlayer,aType, aPos1.X,aPos1.Y,0,1,1);
	A.GroupOrderWalk(Patrolls[I].aID, aPos2.X,aPos2.Y,0);
end;